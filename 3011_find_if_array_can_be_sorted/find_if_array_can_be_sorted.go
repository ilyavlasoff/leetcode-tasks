package main

/*
Source: https://leetcode.com/problems/find-if-array-can-be-sorted

Вам дан индексированный 0 массив положительных целых чисел nums.

За одну операцию вы можете поменять местами любые два соседних элемента, если у них одинаковое количество
установленных битов
. Вы можете выполнять эту операцию любое количество раз (включая ноль).

Верните true, если вы можете отсортировать массив, в противном случае верните false.
*/

func canSortArray(nums []int) bool {
    if len(nums) < 2 {
        return true
    }

	// основная идея решения заключается в том, что так как 
	// числа с разными количествами битов не могут быть переставлены
	// между собой, то изначально их можно поделить на группы последовательных
	// чисел с одинаковым кол-вом битов
	// внутри такой группы последовательность может быть любой
	// но между группами должно соблюдаться правило: минимум в 
	// следующей группе должен быть больше максимума в предыдущей

    var pgMax, gMin, gMax, p int
	// pgMax - макс значение в предыдущей группе
	// gMin - минимальное значние в текущей группе
	// gMax - макс значение в текущей группе
	// p - число битов предыдущего числа в последовательности

    for i, n := range nums {
        c := countOnes(n)
        if i != 0 && c != p { // переход между группами
            if pgMax > gMin {
                return false
            }

            pgMax = gMax
            gMax = 0
            gMin = 1000
        }

		// проверяем и обновляем макс и мин значения
        if n > gMax {
            gMax = n
        }
        if n < gMin {
            gMin = n
        }

        p = c
    }

	// pgMax == 0 значит что не было перехода между группами 
	// то есть все имеют одно и то же колво бит
    return pgMax == 0 || pgMax < gMin
}

func countOnes(num int) int {
    var oneCnt int

    for num != 0 {
        oneCnt += num & 1
        num = num >> 1
    }

    return oneCnt
}